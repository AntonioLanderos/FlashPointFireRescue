# -*- coding: utf-8 -*-
"""FireRescue.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZbv5hZLwHkXjZQMLWtd338HV59T6yUI
"""


# Commented out IPython magic to ensure Python compatibility.
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model

# Debido a que necesitamos que existe un solo agente por celda, elegimos ''SingleGrid''.
from mesa.space import SingleGrid
from mesa.space import MultiGrid

# Con ''SimultaneousActivation, hacemos que todos los agentes se activen ''al mismo tiempo''.
from mesa.time import SimultaneousActivation
from mesa.time import RandomActivation

# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector

from mesa.batchrunner import batch_run

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

import seaborn as sns

class FireRescueAgent(Agent):
  def __init__(self, id, model, agent_type, state=None, position=None):
    super().__init__(id, model)
    self.agent_type = agent_type
    self.state = state
    self.position = position
    self.action_points = 4 if agent_type == "firefighter" else None
    self.carrying_victim = False if agent_type == "firefighter" else None
    self.type = None
    self.walls = None

  def step(self):
    if self.agent_type == "firefighter":
      self.firefighter_step()
    elif self.agent_type == "fire":
      self.fire_step()
    elif self.agent_type == "poi":
      self.poi_step()
    elif self.agent_type == "wall":
      self.wall_step()

  def firefighter_step(self):
    if self.action_points > 0:
        # Abrir/cerrar puerta si hay una en la celda
        for agent in self.model.grid.get_cell_list_contents(self.pos):
            if agent.agent_type == "door":
                agent.toggle_door()
                self.action_points -= 1
                return

        # Moverse si no hay puertas para interactuar
        neighbors = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False)
        valid_moves = [pos for pos in neighbors if self.model.can_move_to(self.pos, pos)]
        if valid_moves:
            new_position = self.random.choice(valid_moves)
            self.model.grid.move_agent(self, new_position)
            self.action_points -= 1
            print(f"Firefighter {self.unique_id} moved to {new_position}")


  def extinguish_fire(self):
    neighbors = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False)
    for neighbor in neighbors:
      for agent in self.model.grid.get_cell_list_contents(neighbor):
        if isinstance(agent, FireRescueAgent) and agent.type == "fire" and agent.state == 'fire':
          agent.state = 'smoke'
          print(f"Fire at {neighbor} extinguished")

  def fire_step(self):
      """Lógica del comportamiento del fuego."""
      if self.state == "smoke":
          neighbors = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False)
          for neighbor in neighbors:
              if any(isinstance(obj, FireRescueAgent) and obj.agent_type == "fire" and obj.state == "fire" for obj in self.model.grid.get_cell_list_contents(neighbor)):
                  self.state = "fire"
                  print(f"Smoke at {self.pos} turned to fire")
                  break
      elif self.state == "fire":
          neighbors = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False)
          for neighbor in neighbors:
              if self.random.random() < 0.5:  # Probabilidad de propagación
                  contents = self.model.grid.get_cell_list_contents(neighbor)
                  # Verificar si hay una víctima en la celda afectada
                  for obj in contents:
                      if isinstance(obj, FireRescueAgent) and obj.agent_type == "poi" and obj.type == "victim":
                          # Aumentar el contador de víctimas perdidas
                          self.model.lost_victims += 1
                          print(f"Victim at {neighbor} lost! Total lost victims: {self.model.lost_victims}")
                          # Eliminar la víctima
                          self.model.grid.remove_agent(obj)
                          self.model.schedule.remove(obj)
                          break
                  # Propagar el fuego si no hay otro fuego en la celda
                  if not any(isinstance(obj, FireRescueAgent) and obj.agent_type == "fire" for obj in contents):
                      new_fire = FireRescueAgent(self.model.next_id(), self.model, "fire", state="smoke", position=neighbor)
                      self.model.grid.place_agent(new_fire, neighbor)
                      self.model.schedule.add(new_fire)
                      print(f"Fire spread to {neighbor}")


  def poi_step(self):
    # check if there is a firefighter in the same cell
    if self.state == 'v':
      for agent in self.model.grid.get_cell_list_contents(self.pos):
        if isinstance(agent, FireRescueAgent) and agent.type == "firefighter":
          agent.carrying_victim = True
          self.model.grid.remove_agent(self)
          break
    else:
      for agent in self.model.grid.get_cell_list_contents(self.pos):
        if isinstance(agent, FireRescueAgent) and agent.type == "firefighter":
          agent.carrying_victim = False
          self.model.grid.remove_agent(self)
          break

  def replenish_poi(self):
    poi_count = sum(1 for agent in self.model.schedule.agents if isinstance(agent, FireRescueAgent) and agent.type == "poi")
    print(f"POI count: {poi_count}")
    while poi_count < 3:
      x, y = self.random.randint(0, self.model.height - 1), self.random.randint(0, self.model.width - 1)
      if len(self.model.grid.get_cell_list_contents((x, y))) == 0:
        poi_type = 'v' if self.random.random() < 0.5 else 'f'
        new_poi = FireRescueAgent(f"poi_{x}_{y}", self.model, "poi", (x, y), poi_type)
        self.model.grid.place_agent(new_poi, (x, y))
        self.model.schedule.add(new_poi)
        poi_count += 1
        print(f"POI replenished at {x}, {y}, as {poi_type}")

  def reveal_poi(self):
    # if there is a firefighter in the same cell, reveal the POI
    for agent in self.model.grid.get_cell_list_contents(self.pos):
      if isinstance(agent, FireRescueAgent) and agent.type == "firefighter":
        self.state = 'v' if self.state == 'f' else 'f'
        print(f"POI at {self.pos} revealed as {self.state}")
        break
    # if the POI is a victim, the firefighter picks it up
    if self.state == 'v':
      self.carrying_victim = True
      print(f"Victim at {self.pos} picked up by firefighter") 

  def wall_step(self):
      """Lógica para las paredes, como recibir daño y destruirse."""
      if self.state and "integrity" in self.state:
          if self.state["integrity"] > 0 and self.state["damage_taken"] > 0:
              print(f"Wall at {self.pos} has taken damage. Current integrity: {self.state['integrity']}")
          if self.state["damage_taken"] >= self.state["integrity"]:
              # Si el daño excede la integridad, destruir la pared
              print(f"Wall at {self.pos} destroyed.")
              self.model.grid.remove_agent(self)
              self.model.schedule.remove(self)
          else:
              # Actualizar el estado visual de la pared si tiene más daño
              print(f"Wall at {self.pos} partially damaged. Integrity remaining: {self.state['integrity'] - self.state['damage_taken']}")

  def take_damage(self, amount=1):
    """Incrementar el daño recibido por la pared."""
    if self.agent_type == "wall" and self.state and "integrity" in self.state:
        self.state["damage_taken"] += amount
        print(f"Wall at {self.pos} took {amount} damage.")

  def move_towards_victim(self):
    """Moverse hacia la víctima más cercana."""
    victim = self.find_closest_victim()
    if victim:
      victim_pos = victim.pos
      if self.model.can_move_to(self.pos, victim_pos):
        self.model.grid.move_agent(self, victim_pos)
        print(f"Firefighter moved to {victim_pos} to save victim.")
      else:
        print(f"Firefighter cannot move to {victim_pos}.")

  def find_closest_victim(self):
    """Buscar la victima mas cercana."""
    victims = [agent for agent in self.model.grid.get_cell_list_contents(self.pos) if isinstance(agent, FireRescueAgent) and agent.type == "poi" and agent.state == 'v']
    if victims:
      return min(victims, key=lambda x: self.model.grid.get_distance(self.pos, x.pos))
    return None

  def move_towards_exit(self):
    """Moverse hacia la salida más cercana."""
    exit_pos = self.find_closest_exit()
    if self.model.can_move_to(self.pos, exit_pos):
      self.model.grid.move_agent(self, exit_pos)
      print(f"Firefighter moved to {exit_pos} to exit the building.")
      # if the firefighter takes a victim to the exit, the victim is saved
      if self.carrying_victim:
        self.carrying_victim = False
        self.model.saved_victims += 1
        print(f"Victim saved by firefighter at {exit_pos}")
      else:
        self.model.lost_victims += 1
        print(f"Firefighter left without saving a victim at")
    else:
      print(f"Firefighter cannot move to {exit_pos}.")

  def find_closest_exit(self):
    """Buscar la salida más cercana."""
    exits = [(x, y) for x in range(self.model.height) for y in range(self.model.width) if self.model.grid.is_cell_empty((x, y))]
    return min(exits, key=lambda x: self.model.grid.get_distance(self.pos, x))
  
  def toggle_door(self):
    """Abrir o cerrar una puerta."""
    if self.agent_type == "door":
        if self.state == "open":
            self.state = "closed"
            print(f"Door at {self.pos} closed.")
        else:
            self.state = "open"
            print(f"Door at {self.pos} opened.")
      
class FireRescueModel(Model):
  def __init__(self, wall_data, poi_data, fire_data, door_data, entry_points):
    super().__init__()
    self.height = 6
    self.width = 8
    self.grid = MultiGrid(self.height, self.width, torus=False)
    self.schedule = RandomActivation(self)
    self.running = True
    self.steps = 0
    self.saved_victims = 0
    self.lost_victims = 0
    self.total_damage_counter = 0
    self.victory_victims = 7
    self.failure_victims = 4

    self.place_walls(wall_data)
    self.place_pois(poi_data)
    self.place_fire(fire_data)
    self.place_doors(door_data)
    self.place_firefighters(entry_points)

    self.datacollector = DataCollector({
        'Grid': self.get_grid,
        'Saved Victims': 'saved_victims',
        'Lost Victims': 'lost_victims',
        'Total Damage': 'total_damage_counter'
    })

  def place_walls(self, wall_data):
    """
    Coloca las paredes en la rejilla según la configuración de `wall_data`.
    Cada entrada de `wall_data` define las paredes presentes en cada celda de la rejilla.
    """
    for x in range(self.height):
        for y in range(self.width):
            wall_config = wall_data[x][y]  # Obtiene la configuración de la celda (e.g., "1100")
            if wall_config != "0000":  # Solo coloca paredes si hay restricciones
                wall_agent = FireRescueAgent(
                    id=f"wall_{x}_{y}",
                    model=self,
                    agent_type="wall",
                    state={"integrity": 2, "damage_taken": 0, "walls": wall_config},
                    position=(x, y)
                )
                self.grid.place_agent(wall_agent, (x, y))
                self.schedule.add(wall_agent)
                print(f"Placed wall at {(x, y)} with config {wall_config}")

  def place_pois(self, poi_data):
    for x, y, poi_type in poi_data:
      poi_agent = FireRescueAgent(f"poi_{x}_{y}", self, 'poi', state=poi_type)
      self.grid.place_agent(poi_agent, (x - 1, y - 1))
      self.schedule.add(poi_agent)

  def place_fire(self, fire_data):
    for x, y in fire_data:
      fire_agent = FireRescueAgent(f"fire_{x}_{y}", self, 'fire', state='smoke')
      self.grid.place_agent(fire_agent, (x - 1, y - 1))
      self.schedule.add(fire_agent)

  def add_fire(self, pos):
    for agent in self.grid.get_cell_list_contents(pos):
      if isinstance(agent, FireRescueAgent) and agent.type == "fire":
        agent.state = 'fire'
        print(f"Fire at {pos} started")

  def place_doors(self, door_data):
    for r1, c1, r2, c2 in door_data:
      door_agent = FireRescueAgent(
         id=f"door_{r1}_{c1}_{r2}_{c2}",
          model=self,
          agent_type="door",
          state={'is_open': False},
          position=((r1, c1), (r2, c2))
      )
      self.grid.place_agent(door_agent, (r1 - 1, c1 - 1))
      self.schedule.add(door_agent)

  def place_firefighters(self, entry_points):
    for i, (x, y) in enumerate(entry_points):
      firefighter = FireRescueAgent(f"firefighter_{i}", self, 'firefighter')
      self.grid.place_agent(firefighter, (x - 1, y - 1))
      self.schedule.add(firefighter)

  def interact_with_walls(self, pos, damage=1):
    """Interacción con paredes en una posición específica."""
    for agent in self.grid.get_cell_list_contents(pos):
        if agent.agent_type == "wall":
            agent.take_damage(damage)
            self.total_damage_counter += damage

  def is_accessible(self, direction):
      """Verifica si la pared permite acceso desde una dirección específica."""
      directions = {"top": 0, "left": 1, "bottom": 2, "right": 3}
      if direction in directions and self.walls[directions[direction]] == "1":
          return False  # La dirección está bloqueada por una pared
      return True


  def can_move_to(self, current_pos, target_pos):
      """Valida si un agente puede moverse de `current_pos` a `target_pos`."""
      x, y = current_pos
      tx, ty = target_pos

      # Determinar la dirección del movimiento
      direction = None
      if tx == x - 1 and ty == y:
          direction = "top"
      elif tx == x + 1 and ty == y:
          direction = "bottom"
      elif tx == x and ty == y - 1:
          direction = "left"
      elif tx == x and ty == y + 1:
          direction = "right"

      # Validar que la dirección sea válida
      if not direction:
          print(f"Invalid movement direction from {current_pos} to {target_pos}")
          return False

      # Verificar si hay una puerta entre `current_pos` y `target_pos`
      for agent in self.grid.get_cell_list_contents(current_pos):
          if agent.agent_type == "door" and ((x, y) in agent.position and (tx, ty) in agent.position):
              if agent.state["is_open"]:
                  return True  # La puerta está abierta, permitir el movimiento
              else:
                  print(f"Blocked by closed door between {current_pos} and {target_pos}.")
                  return False  # La puerta está cerrada, bloquear el movimiento

      # Verificar si hay paredes en la posición actual
      for agent in self.grid.get_cell_list_contents(current_pos):
          if agent.agent_type == "wall":
              if not self.is_accessible(agent, direction):
                  print(f"Blocked by wall at {current_pos} in direction {direction}")
                  return False

      # Si no hay bloqueos, permitir el movimiento
      return True



  def get_grid(self):
    """
    Genera una representación numérica de la rejilla actual.
    - 0: Celda vacía
    - 1: Firefighter
    - 2: Fire
    - 3: POI
    - 4: Wall
    - 5: Puerta cerrada
    - 6: Puerta abierta
    """
    grid = np.zeros((self.grid.width, self.grid.height))
    for content, x, y in self.grid.coord_iter():
        for agent in content:
            if agent.agent_type == "firefighter":
                grid[x][y] = 1
            elif agent.agent_type == "fire":
                grid[x][y] = 2 if agent.state == "fire" else 0.5
            elif agent.agent_type == "poi":
                grid[x][y] = 3 if agent.type == "victim" else 2.5
            elif agent.agent_type == "wall":
                grid[x][y] = 4
            elif agent.agent_type == "door":
                grid[x][y] = 6 if agent.state["is_open"] else 5
    return grid


  def step(self):
    self.steps += 1
    self.schedule.step()
    self.datacollector.collect(self)

    if self.saved_victims >= self.victory_victims:
      self.running = False
      print("Victory")
    elif self.lost_victims >= self.failure_victims or self.total_damage_counter >= 24:
      self.running = False
      print("Game over")

with open("final.txt", "r") as file:
        lines = file.readlines()

wall_data = [line.split() for line in lines[:6]]
poi_data = [(int(x), int(y), t) for x, y, t in [line.split() for line in lines[6:9]]]
fire_data = [(int(x), int(y)) for x, y in [line.split() for line in lines[9:19]]]
door_data = [tuple(map(int, line.split())) for line in lines[19:27]]
entry_points = [tuple(map(int, line.split())) for line in lines[27:31]]

# Imprimir los resultados para verificar
print("Walls Matrix:")
for row in wall_data:
    print(row)

print("\nPOI Matrix:")
for row in poi_data:
    print(row)

print("\nFire Matrix:")
for row in fire_data:
    print(row)

print("\nDoors Matrix:")
for row in door_data:
    print(row)

print("\nEntry Points Matrix:")
for row in entry_points:
    print(row)

# Crear modelo
model = FireRescueModel(wall_data, poi_data, fire_data, door_data, entry_points)

# Ejecutar simulación
while model.running and model.steps < 1000:
  model.step()

# Imprimir resultados
all_grids = model.datacollector.get_model_vars_dataframe()
print(all_grids.head(5))

fig, axis = plt.subplots(figsize = (4, 4))
axis.set_xticks([])
axis.set_yticks([])
patch = plt.imshow(all_grids.iloc[0][0], cmap = plt.cm.binary)

def animate(i):
  patch.set_data(all_grids.iloc[i][0])

anim = animation.FuncAnimation(fig, animate, frames = len(all_grids))

plt.show()


